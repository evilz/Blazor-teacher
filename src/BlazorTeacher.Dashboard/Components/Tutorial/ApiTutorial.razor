@page "/tutorial/api"
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime

<PageTitle>API Development Tutorial</PageTitle>

<div class="tutorial-page">
    <h1>üöÄ REST API Development with .NET 10</h1>
    <p class="subtitle">Learn to build a complete CRUD API using ASP.NET Core, EF Core, and SQLite</p>

    <nav class="tutorial-toc">
        <h3>Table of Contents</h3>
        <ul>
            <li><a href="#setup">Environment Setup</a></li>
            <li><a href="#structure">Solution Structure</a></li>
            <li><a href="#domain">Domain Modeling</a></li>
            <li><a href="#efcore">EF Core & SQLite</a></li>
            <li><a href="#migrations">Database Migrations</a></li>
            <li><a href="#validation">Input Validation</a></li>
            <li><a href="#error-handling">Error Handling</a></li>
            <li><a href="#logging">Logging with Serilog</a></li>
        </ul>
    </nav>

    <section id="setup" class="tutorial-section">
        <h2>1. Environment Setup</h2>
        <p>First, ensure you have .NET 10 SDK installed. Create a new solution with the following structure:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Terminal Commands</div>
            <pre><code class="language-bash"># Create solution and projects
dotnet new sln -n BlazorTeacher
mkdir src
cd src

# Create Web API project
dotnet new webapi -n BlazorTeacher.Api --use-controllers

# Create Shared library for DTOs and Models
dotnet new classlib -n BlazorTeacher.Shared

# Add projects to solution
cd ..
dotnet sln add src/BlazorTeacher.Api
dotnet sln add src/BlazorTeacher.Shared

# Add required packages to API project
cd src/BlazorTeacher.Api
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package FluentValidation.AspNetCore
dotnet add package Serilog.AspNetCore
dotnet add reference ../BlazorTeacher.Shared</code></pre>
        </div>
    </section>

    <section id="structure" class="tutorial-section">
        <h2>2. Solution Structure</h2>
        <p>Our solution follows a clean architecture approach with clear separation of concerns:</p>
        
        <div class="tutorial-file-tree">
            <div class="tree-item folder">üìÅ BlazorTeacher/</div>
            <div class="tree-item folder indent-1">üìÅ src/</div>
            <div class="tree-item folder indent-2">üìÅ BlazorTeacher.Api/</div>
            <div class="tree-item folder indent-3">üìÅ Controllers/ - API endpoints</div>
            <div class="tree-item folder indent-3">üìÅ Data/ - DbContext and configurations</div>
            <div class="tree-item folder indent-3">üìÅ Middleware/ - Error handling, logging</div>
            <div class="tree-item folder indent-3">üìÅ Validators/ - FluentValidation validators</div>
            <div class="tree-item folder indent-3">üìÅ Extensions/ - Mapping extensions</div>
            <div class="tree-item indent-3">üìÑ Program.cs - Application entry point</div>
            <div class="tree-item folder indent-2">üìÅ BlazorTeacher.Shared/</div>
            <div class="tree-item folder indent-3">üìÅ Models/ - Domain entities</div>
            <div class="tree-item folder indent-3">üìÅ DTOs/ - Data Transfer Objects</div>
        </div>
    </section>

    <section id="domain" class="tutorial-section">
        <h2>3. Domain Modeling</h2>
        <p>Define your domain entities in the Shared project. Here's our Course entity:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Models/Course.cs</div>
            <pre><code class="language-csharp">public class Course
{
    public int Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Instructor { get; set; } = string.Empty;
    public int DurationInHours { get; set; }
    public decimal Price { get; set; }
    public CourseLevel Level { get; set; }
    public bool IsPublished { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? UpdatedAt { get; set; }
    
    // Navigation property for one-to-many relationship
    public ICollection&lt;Lesson&gt; Lessons { get; set; } = new List&lt;Lesson&gt;();
}

public enum CourseLevel
{
    Beginner = 0,
    Intermediate = 1,
    Advanced = 2
}</code></pre>
        </div>

        <div class="tutorial-info-box">
            <strong>üí° Best Practice:</strong> Use DTOs (Data Transfer Objects) to separate your API contract from your domain models. This allows you to change your internal models without breaking API consumers.
        </div>
    </section>

    <section id="efcore" class="tutorial-section">
        <h2>4. EF Core & SQLite Configuration</h2>
        <p>Create a DbContext to configure Entity Framework Core with SQLite:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Data/AppDbContext.cs</div>
            <pre><code class="language-csharp">public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) 
        : base(options) { }

    public DbSet&lt;Course&gt; Courses =&gt; Set&lt;Course&gt;();
    public DbSet&lt;Lesson&gt; Lessons =&gt; Set&lt;Lesson&gt;();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure Course entity
        modelBuilder.Entity&lt;Course&gt;(entity =&gt;
        {
            entity.HasKey(c =&gt; c.Id);
            entity.Property(c =&gt; c.Title)
                .IsRequired()
                .HasMaxLength(200);
            entity.Property(c =&gt; c.Price)
                .HasPrecision(18, 2);
                
            // Configure one-to-many relationship
            entity.HasMany(c =&gt; c.Lessons)
                .WithOne(l =&gt; l.Course)
                .HasForeignKey(l =&gt; l.CourseId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}</code></pre>
        </div>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Program.cs - Service Registration</div>
            <pre><code class="language-csharp">// Configure SQLite with EF Core
builder.Services.AddDbContext&lt;AppDbContext&gt;(options =&gt;
    options.UseSqlite(builder.Configuration
        .GetConnectionString("DefaultConnection") 
        ?? "Data Source=blazorteacher.db"));</code></pre>
        </div>
    </section>

    <section id="migrations" class="tutorial-section">
        <h2>5. Database Migrations</h2>
        <p>Use EF Core migrations to manage database schema changes:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Terminal Commands</div>
            <pre><code class="language-bash"># Create initial migration
dotnet ef migrations add InitialCreate

# Apply migrations to database
dotnet ef database update

# Create migration after model changes
dotnet ef migrations add AddNewField

# Remove last migration (if not applied)
dotnet ef migrations remove</code></pre>
        </div>

        <div class="tutorial-info-box warning">
            <strong>‚ö†Ô∏è Note:</strong> In this tutorial, we use <code>EnsureCreated()</code> for simplicity. In production, always use migrations for proper schema management.
        </div>
    </section>

    <section id="validation" class="tutorial-section">
        <h2>6. Input Validation with FluentValidation</h2>
        <p>Use FluentValidation for robust, testable validation rules:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Validators/CourseValidators.cs</div>
            <pre><code class="language-csharp">public class CreateCourseValidator : AbstractValidator&lt;CreateCourseDto&gt;
{
    public CreateCourseValidator()
    {
        RuleFor(x =&gt; x.Title)
            .NotEmpty().WithMessage("Title is required.")
            .MaximumLength(200).WithMessage("Title cannot exceed 200 characters.");

        RuleFor(x =&gt; x.DurationInHours)
            .GreaterThan(0).WithMessage("Duration must be greater than 0.");

        RuleFor(x =&gt; x.Price)
            .GreaterThanOrEqualTo(0).WithMessage("Price cannot be negative.");

        RuleFor(x =&gt; x.Level)
            .IsInEnum().WithMessage("Invalid course level.");
    }
}</code></pre>
        </div>
    </section>

    <section id="error-handling" class="tutorial-section">
        <h2>7. Global Error Handling</h2>
        <p>Implement middleware for centralized exception handling:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Middleware/GlobalExceptionMiddleware.cs</div>
            <pre><code class="language-csharp">public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;GlobalExceptionMiddleware&gt; _logger;

    public GlobalExceptionMiddleware(RequestDelegate next, 
        ILogger&lt;GlobalExceptionMiddleware&gt; logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
            
            context.Response.StatusCode = 500;
            context.Response.ContentType = "application/json";
            
            await context.Response.WriteAsJsonAsync(new 
            { 
                Message = "An unexpected error occurred" 
            });
        }
    }
}</code></pre>
        </div>
    </section>

    <section id="logging" class="tutorial-section">
        <h2>8. Structured Logging with Serilog</h2>
        <p>Configure Serilog for structured, queryable logs:</p>
        
        <div class="tutorial-code-block">
            <div class="tutorial-code-header">Program.cs</div>
            <pre><code class="language-csharp">using Serilog;

Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console()
    .WriteTo.File("logs/api-.log", rollingInterval: RollingInterval.Day)
    .Enrich.FromLogContext()
    .CreateLogger();

try
{
    Log.Information("Starting API");
    
    var builder = WebApplication.CreateBuilder(args);
    builder.Host.UseSerilog();
    
    // ... rest of configuration
    
    app.Run();
}
catch (Exception ex)
{
    Log.Fatal(ex, "Application terminated unexpectedly");
}
finally
{
    Log.CloseAndFlush();
}</code></pre>
        </div>
    </section>

    <div class="tutorial-next-steps">
        <h3>üéØ Next Steps</h3>
        <p>Now that you understand the API architecture, explore the Blazor components tutorial to learn how to build a dashboard that consumes this API!</p>
        <a href="/tutorial/components" class="tutorial-btn tutorial-btn-primary">Continue to Components Tutorial ‚Üí</a>
    </div>
</div>

@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("PrismHelper.highlightAll");
        }
    }
}
